<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>NISHIDEMASAMI.GITHUB.IO</title>
        <link>https://nishidemasami.github.io</link>
        <description>個人のブログです。有益なことや無益なことなどいろいろ書いています。</description>
        <lastBuildDate>Sat, 24 Dec 2022 16:19:10 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>ja</language>
        <copyright>©NISHIDE, Masami All rights reserved.</copyright>
        <atom:link href="https://nishidemasami.github.io/feed" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[Typescriptでビットコインアドレスを生成する]]></title>
            <link>https://nishidemasami.github.io/articles/typescript-bitcoin</link>
            <guid>https://nishidemasami.github.io/articles/typescript-bitcoin</guid>
            <pubDate>Fri, 23 Dec 2022 16:04:03 GMT</pubDate>
            <description><![CDATA[Typescriptでビットコインアドレスを生成したいこと、ありますよね。僕はあるので自分用にメモです。]]></description>
            <content:encoded><![CDATA[*/

import React from 'react';

import { format } from 'date-fns';
import { GetStaticProps } from 'next';

import { TypescriptBitcoin } from '../../components/TypescriptBitcoin';
import { Content } from '../../content/Content';
import { Meta } from '../../layout/Meta';
import { PostPagination } from '../../pagination/PostPagination';
import { Main } from '../../templates/Main';
import {
	getPrevNextPost,
	getRecentPosts,
	getTags,
	PostItems,
} from '../../utils/Content';
import { markdownToHtml } from '../../utils/Markdown';

type ReactSoundTestProps = {
	recents: PostItems[];
	tags: string[];
	firstArticle: string;
	secondArticle: string;
	prevPost?: PostItems;
	nextPost?: PostItems;
};

const firstArticle = `
Typescriptでビットコインアドレスを生成したいこと、ありますよね。  
僕はあるので自分用にメモです。<sup>[<a target="_blank" href="https://www.amazon.co.jp/%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%83%81%E3%82%A7%E3%83%BC%E3%83%B3%E5%AE%9F%E8%B7%B5%E5%85%A5%E9%96%80-%E3%83%93%E3%83%83%E3%83%88%E3%82%B3%E3%82%A4%E3%83%B3%E3%81%8B%E3%82%89%E3%82%A4%E3%83%BC%E3%82%B5%E3%83%AA%E3%82%A2%E3%83%A0%E3%80%81DApp%E9%96%8B%E7%99%BA%E3%81%BE%E3%81%A7-Bikramaditya-Singhal/dp/4274225372?_encoding=UTF8&qid=1671896601&sr=8-1&linkCode=ll1&tag=nishidemasami-22&linkId=b026b2c2bd3729a8fe4c35dda528a7bb&language=ja_JP&ref_=as_li_ss_tl" rel="noreferrer" >参考文献</a>]</sup>

👇このボタンをクリックするとビットコインアドレスを生成します。
`;

const secondArticle = `
ビットコインのアドレスは、32バイトの秘密鍵を以下のようにしてビットコインアドレスに変換します。

\`\`\`mermaid
flowchart TD

A[32バイトの秘密鍵] -->|secp256k1| B(公開鍵)
A -->|base58変換とチェックサム付与| F[WIF形式秘密鍵]
B --> C{ビットコインアドレス形式}
C -->|BASE58変換とチェックサム付与| D[P2PKH形式ビットコインアドレス]
C -->|BASE32変換とチェックサム付与| E[Bech32形式ビットコインアドレス]
\`\`\`

これはTypescriptでも簡単に計算できます。

それを実際に書いてみたのが ↓ この今回のコードです
\`\`\`typescript
import { randomBytes, createHash, BinaryLike } from 'crypto';

import { useState, FC, useMemo, useCallback } from 'react';

import { Button, TextField } from '@mui/material';
import { bech32 } from 'bech32';
import { encode } from 'bs58';
import RIPEMD160 from 'ripemd160';
import { publicKeyCreate, privateKeyVerify } from 'secp256k1';

/** 16進数の文字列かどうかチェックする正規表現 */
const check32BytesHex = /^[0-9a-fA-F]{64}$/;

/** 16進数の文字列をUint8Arrayに変換する */
const hexToUint8Array = (hex: string): Uint8Array => Buffer.from(hex, 'hex');

/** Bufferを16進数の文字列に変換する */
const bufferToHex = (data: Buffer): string => data.toString('hex');

/** sha256でハッシュする */
const sha256 = (data: BinaryLike): Buffer =>
  createHash('sha256').update(data).digest();

/** ripemd160でハッシュする */
const ripemd160 = (data: BinaryLike): Buffer =>
  new RIPEMD160().update(data).digest();

/** BASE58チェックサム生成 */
const calcBase58Checksum = (data: BinaryLike): Buffer =>
  sha256(sha256(data)).subarray(0, 4);

/** BASE58変換＋チェックサム */
const base58WithChecksum = (data: Uint8Array): string =>
  encode([...data, ...calcBase58Checksum(data)]);

/** ビットコインアドレス(BASE58(P2PKH)形式)生成 */
const genBitcoinAddressP2PKH = (publicKey: Uint8Array): string =>
  base58WithChecksum(Uint8Array.from([0x00, ...ripemd160(sha256(publicKey))]));

/** BASE32変換＋チェックサム */
const bech32WithChecksum = (data: Uint8Array) =>
  bech32.encode('bc', [0x00, ...bech32.toWords(data)]);

/** ビットコインアドレス(BASE32(Bech32)形式)生成 */
const genBitcoinAddressBECH32 = (publicKey: Uint8Array): string =>
  bech32WithChecksum(ripemd160(sha256(publicKey)));

/** 秘密鍵(WIF形式)生成 */
const genWif = (privateKey: Uint8Array): string =>
  base58WithChecksum(Uint8Array.from([0x80, ...privateKey]));

const TypescriptBitcoin: FC = () => {
  // 秘密鍵(32バイトの16進数)
  const [hexPrivateKey, setHexPrivateKey] = useState(
    bufferToHex(randomBytes(32))
  );

  /** 秘密鍵(32バイト) */
  const privateKey: Uint8Array | string = useMemo(() => {
    if (!check32BytesHex.test(hexPrivateKey))
      return '秘密鍵が32バイトの16進数ではない';
    return hexToUint8Array(hexPrivateKey);
  }, [hexPrivateKey]);

  /** 公開鍵 */
  const publicKey: Uint8Array | string = useMemo(() => {
    if (typeof privateKey === 'string') return privateKey;
    if (!privateKeyVerify(privateKey)) return '秘密鍵が不適切';
    return publicKeyCreate(privateKey, false);
  }, [privateKey]);

  /** ビットコインアドレス(BASE32(Bech32)形式) */
  const bitcoinAddressBECH32 = useMemo(() => {
    if (typeof privateKey === 'string') return privateKey;
    if (typeof publicKey === 'string') return publicKey;
    return genBitcoinAddressBECH32(publicKey);
  }, [privateKey, publicKey]);

  /** ビットコインアドレス(BASE58(P2PKH)形式) */
  const bitcoinAddressP2PKH = useMemo(() => {
    if (typeof privateKey === 'string') return privateKey;
    if (typeof publicKey === 'string') return publicKey;
    return genBitcoinAddressP2PKH(publicKey);
  }, [privateKey, publicKey]);

  /** 秘密鍵をランダムに生成 */
  const genRamdamKey = useCallback(
    () => setHexPrivateKey(bufferToHex(randomBytes(32))),
    []
  );

  /** 秘密鍵(WIF形式) */
  const wif = useMemo(
    () => genWif(hexToUint8Array(hexPrivateKey)),
    [hexPrivateKey]
  );

  return (
    <>
      <Button onClick={genRamdamKey} variant="outlined">
        秘密鍵をランダムに生成
      </Button>
      <TextField
        error={!check32BytesHex.test(hexPrivateKey)}
        fullWidth
        label="秘密鍵(32バイトの16進数)"
        margin="dense"
        value={hexPrivateKey}
        onChange={(e) => {
          setHexPrivateKey(e.currentTarget.value);
        }}
      />
      <TextField
        fullWidth
        label="秘密鍵(WIF形式)"
        margin="dense"
        value={wif}
        InputProps={{
          readOnly: true,
        }}
      />
      <TextField
        fullWidth
        label="ビットコインアドレス(BASE58(P2PKH)形式)"
        margin="dense"
        InputProps={{
          readOnly: true,
        }}
        value={bitcoinAddressP2PKH}
      />
      <TextField
        fullWidth
        label="ビットコインアドレス(BASE32(Bech32)形式)"
        margin="dense"
        InputProps={{
          readOnly: true,
        }}
        value={bitcoinAddressBECH32}
      />
    </>
  );
};

export { TypescriptBitcoin };
\`\`\`
`;

const ReactSoundTest = (props: ReactSoundTestProps) => (
	<Main
		recents={props.recents}
		tags={props.tags}
		meta={
			<Meta
				title="Typescriptでビットコインアドレスを生成する"
				description="Typescriptでビットコインアドレスを生成したいこと、ありますよね。僕はあるので自分用にメモです。"
			/>
		}
	>
		<h1 className="text-center font-bold text-3xl text-gray-900">
			Typescriptでビットコインアドレスを生成する
		</h1>
		<div className="text-center text-sm mb-4">
			{format(new Date('2022-12-10T01:04:03+0900'), 'LLLL d, yyyy')}
		</div>

		<Content>
			<div>
				<div dangerouslySetInnerHTML={{ __html: props.firstArticle }} />
				<TypescriptBitcoin />
				<div dangerouslySetInnerHTML={{ __html: props.secondArticle }} />
			</div>
		</Content>

		<PostPagination nextPost={props.nextPost} prevPost={props.prevPost} />
	</Main>
);

export const getStaticProps: GetStaticProps<ReactSoundTestProps> = async () => {
	const recents = getRecentPosts(['title', 'date', 'slug']);

	return {
		props: {
			recents,
			tags: getTags(),
			firstArticle: await markdownToHtml(firstArticle),
			secondArticle: await markdownToHtml(secondArticle),
			...getPrevNextPost(__filename),
		},
	};
};

export default ReactSoundTest;
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Next.jsでSSG時にRemarkでMermaidをSVGとして出力する]]></title>
            <link>https://nishidemasami.github.io/posts/nextjs-mermaid</link>
            <guid>https://nishidemasami.github.io/posts/nextjs-mermaid</guid>
            <pubDate>Sun, 18 Dec 2022 14:04:03 GMT</pubDate>
            <description><![CDATA[Next.jsでSSG時にRemarkでMermaidをSVGにして出力してみたいと思うこと、ありますよね。僕はあるのですがネット上にあまり情報が無かったので自分用にメモです。]]></description>
            <content:encoded><![CDATA[
Next.jsでSSG時にRemarkでMermaidをSVGにして出力してみたいと思うこと、ありますよね。  
僕はあるのですがネット上にあまり情報が無かったので自分用にメモです。

今回は`remark-mermaidjs`を使って実装しました。

このサイトではMarkdownを`unified`で扱っているので`remark-mermaidjs`を`use`します。  
`remark-mermaidjs`はGoogle Chromeを使ってMermaidをSVGにしているらしく`executablePath`でGoogle Chromeのパスを指定しなければならないようです。  
このサイトはGitHub Actionsでビルドしているので、ubuntuのために`/opt/google/chrome/google-chrome`を指定しました。なお、ローカル環境でも自由に動かせるように`.env`にもGoogle Chromeへのパスを書くことにしました。

```typescript
// @ts-ignore
import rehypePrism from '@mapbox/rehype-prism';
import rehypeKatex from 'rehype-katex';
import rehypeStringify from 'rehype-stringify';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import remarkMermaid from 'remark-mermaidjs';
import remarkParse from 'remark-parse';
import remarkRehype from 'remark-rehype';
import { unified } from 'unified';

export const markdownToHtml = async (markdown: string) =>
  (
    await unified()
      .use(remarkParse)
      .use(remarkMath)
      .use(remarkGfm)
      .use(remarkMermaid, {
        launchOptions: {
          executablePath:
            process.env.GoogleChromeExecutablePath ?? // .env
            '/opt/google/chrome/google-chrome', // for GitHub Actions Ubuntu
        },
        svgo: false,
      })
      .use(remarkRehype, { allowDangerousHtml: true, footnoteLabel: '脚注' })
      .use(rehypePrism)
      .use(rehypeKatex)
      .use(rehypeStringify, { allowDangerousHtml: true })
      .process(markdown)
  )
    .toString()
    .replace(/@@baseUrl@@/g, process.env.baseUrl || '');
```

以下にサンプルを置いておきます。図がSVGになっていることがわかると思います。

## Flowchart

````markdown
```mermaid
flowchart LR

A[Hard] -->|Text| B(Round)
B --> C{Decision}
C -->|One| D[Result 1]
C -->|Two| E[Result 2]
```
````

```mermaid
flowchart LR

A[Hard] -->|Text| B(Round)
B --> C{Decision}
C -->|One| D[Result 1]
C -->|Two| E[Result 2]
```

## Sequence diagram

````markdown
```mermaid
sequenceDiagram
Alice->>John: Hello John, how are you?
loop Healthcheck
    John->>John: Fight against hypochondria
end
Note right of John: Rational thoughts!
John-->>Alice: Great!
John->>Bob: How about you?
Bob-->>John: Jolly good!
```
````

```mermaid
sequenceDiagram
Alice->>John: Hello John, how are you?
loop Healthcheck
    John->>John: Fight against hypochondria
end
Note right of John: Rational thoughts!
John-->>Alice: Great!
John->>Bob: How about you?
Bob-->>John: Jolly good!
```

## Gantt chart

````markdown
```mermaid
gantt
    section Section
    Completed :done,    des1, 2014-01-06,2014-01-08
    Active        :active,  des2, 2014-01-07, 3d
    Parallel 1   :         des3, after des1, 1d
    Parallel 2   :         des4, after des1, 1d
    Parallel 3   :         des5, after des3, 1d
    Parallel 4   :         des6, after des4, 1d
```
````

```mermaid
gantt
    section Section
    Completed :done,    des1, 2014-01-06,2014-01-08
    Active        :active,  des2, 2014-01-07, 3d
    Parallel 1   :         des3, after des1, 1d
    Parallel 2   :         des4, after des1, 1d
    Parallel 3   :         des5, after des3, 1d
    Parallel 4   :         des6, after des4, 1d
```

## Class diagram

````markdown
```mermaid
classDiagram
Class01 <|-- AveryLongClass : Cool
<<Interface>> Class01
Class09 --> C2 : Where am I?
Class09 --* C3
Class09 --|> Class07
Class07 : equals()
Class07 : Object[] elementData
Class01 : size()
Class01 : int chimp
Class01 : int gorilla
class Class10 {
  <<service>>
  int id
  size()
}
```
````

```mermaid
classDiagram
Class01 <|-- AveryLongClass : Cool
<<Interface>> Class01
Class09 --> C2 : Where am I?
Class09 --* C3
Class09 --|> Class07
Class07 : equals()
Class07 : Object[] elementData
Class01 : size()
Class01 : int chimp
Class01 : int gorilla
class Class10 {
  <<service>>
  int id
  size()
}
```

## Git graph

````markdown
```mermaid
gitGraph
    commit
    commit
    branch develop
    commit
    commit
    commit
    checkout main
    commit
    commit
```
````

```mermaid
gitGraph
    commit
    commit
    branch develop
    commit
    commit
    commit
    checkout main
    commit
    commit
```

## State diagram

````markdown
```mermaid
stateDiagram-v2
[*] --> Still
Still --> [*]
Still --> Moving
Moving --> Still
Moving --> Crash
Crash --> [*]
```
````

```mermaid
stateDiagram-v2
[*] --> Still
Still --> [*]
Still --> Moving
Moving --> Still
Moving --> Crash
Crash --> [*]
```

## Pie chart

````markdown
```mermaid
pie
"Dogs" : 386
"Cats" : 85.9
"Rats" : 15
```
````

```mermaid
pie
"Dogs" : 386
"Cats" : 85.9
"Rats" : 15
```

## Entity Relationship Diagram

````markdown
```mermaid
erDiagram
    CUSTOMER ||--o{ ORDER : places
    ORDER ||--|{ LINE-ITEM : contains
    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses
```
````

```mermaid
erDiagram
    CUSTOMER ||--o{ ORDER : places
    ORDER ||--|{ LINE-ITEM : contains
    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses
```

## User Journey diagram

````markdown
```mermaid
journey
  title My working day
  section Go to work
    Make tea: 5: Me
    Go upstairs: 3: Me
    Do work: 1: Me, Cat
  section Go home
    Go downstairs: 5: Me
    Sit down: 3: Me
```
````

```mermaid
journey
  title My working day
  section Go to work
    Make tea: 5: Me
    Go upstairs: 3: Me
    Do work: 1: Me, Cat
  section Go home
    Go downstairs: 5: Me
    Sit down: 3: Me
```

## C4 diagram

````markdown
```mermaid
C4Context
title System Context diagram for Internet Banking System

Person(customerA, "Banking Customer A", "A customer of the bank, with personal bank accounts.")
Person(customerB, "Banking Customer B")
Person_Ext(customerC, "Banking Customer C")
System(SystemAA, "Internet Banking System", "Allows customers to view information about their bank accounts, and make payments.")

Person(customerD, "Banking Customer D", "A customer of the bank, <br/> with personal bank accounts.")

Enterprise_Boundary(b1, "BankBoundary") {

  SystemDb_Ext(SystemE, "Mainframe Banking System", "Stores all of the core banking information about customers, accounts, transactions, etc.")

  System_Boundary(b2, "BankBoundary2") {
    System(SystemA, "Banking System A")
    System(SystemB, "Banking System B", "A system of the bank, with personal bank accounts.")
  }

  System_Ext(SystemC, "E-mail system", "The internal Microsoft Exchange e-mail system.")
  SystemDb(SystemD, "Banking System D Database", "A system of the bank, with personal bank accounts.")

  Boundary(b3, "BankBoundary3", "boundary") {
    SystemQueue(SystemF, "Banking System F Queue", "A system of the bank, with personal bank accounts.")
    SystemQueue_Ext(SystemG, "Banking System G Queue", "A system of the bank, with personal bank accounts.")
  }
}

BiRel(customerA, SystemAA, "Uses")
BiRel(SystemAA, SystemE, "Uses")
Rel(SystemAA, SystemC, "Sends e-mails", "SMTP")
Rel(SystemC, customerA, "Sends e-mails to")
```
````

````mermaid
C4Context
title System Context diagram for Internet Banking System

Person(customerA, "Banking Customer A", "A customer of the bank, with personal bank accounts.")
Person(customerB, "Banking Customer B")
Person_Ext(customerC, "Banking Customer C")
System(SystemAA, "Internet Banking System", "Allows customers to view information about their bank accounts, and make payments.")

Person(customerD, "Banking Customer D", "A customer of the bank, <br/> with personal bank accounts.")

Enterprise_Boundary(b1, "BankBoundary") {

  SystemDb_Ext(SystemE, "Mainframe Banking System", "Stores all of the core banking information about customers, accounts, transactions, etc.")

  System_Boundary(b2, "BankBoundary2") {
    System(SystemA, "Banking System A")
    System(SystemB, "Banking System B", "A system of the bank, with personal bank accounts.")
  }

  System_Ext(SystemC, "E-mail system", "The internal Microsoft Exchange e-mail system.")
  SystemDb(SystemD, "Banking System D Database", "A system of the bank, with personal bank accounts.")

  Boundary(b3, "BankBoundary3", "boundary") {
    SystemQueue(SystemF, "Banking System F Queue", "A system of the bank, with personal bank accounts.")
    SystemQueue_Ext(SystemG, "Banking System G Queue", "A system of the bank, with personal bank accounts.")
  }
}

BiRel(customerA, SystemAA, "Uses")
BiRel(SystemAA, SystemE, "Uses")
Rel(SystemAA, SystemC, "Sends e-mails", "SMTP")
Rel(SystemC, customerA, "Sends e-mails to")
````

Mermaid記法なら簡単にグラフを書けて便利なので、どんどん使っていきたいと思います。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SVGだけで作ったSVGマニ車をCSSでクルクル回して自動で徳を積む]]></title>
            <link>https://nishidemasami.github.io/posts/svg-prayer-wheel</link>
            <guid>https://nishidemasami.github.io/posts/svg-prayer-wheel</guid>
            <pubDate>Fri, 16 Dec 2022 16:04:03 GMT</pubDate>
            <description><![CDATA[徳、積みたいですよね。JavaScriptを使わずにSVGとCSSだけでマニ車をクルクル回して自動で徳を積みたいこと、ありますよね。僕はあるので自分用にメモです。]]></description>
            <content:encoded><![CDATA[
<style>
  #Text1{animation: spin 11s linear infinite; transform-origin: center;}
  #Text2{animation: spin 10s linear infinite; transform-origin: center;}
  #Text3{animation: spin 9s linear infinite; transform-origin: center;}
  #Text4{animation: spin 8s linear infinite; transform-origin: center;}
  #Text5{animation: spin 7s linear infinite; transform-origin: center;}
  #Text6{animation: spin 6s linear infinite; transform-origin: center;}
  #Text7{animation: spin 5s linear infinite; transform-origin: center;}
  #Text8{animation: spin 4s linear infinite; transform-origin: center;}
  #Text9{animation: spin 3s linear infinite; transform-origin: center;}
</style>
<svg style="max-width:400px" viewBox="0 0 400 400" >
  <defs>
    <path id="Circle1" d="M 25, 200 a 175,175 0 1,1 350,0 a 175,175 0 1,1 -350,0" />
    <path id="Circle2" d="M 50, 200 a 150,150 0 1,1 300,0 a 150,150 0 1,1 -300,0" />
    <path id="Circle3" d="M 75, 200 a 125,125 0 1,1 250,0 a 125,125 0 1,1 -250,0" />
    <path id="Circle4" d="M 100, 200 a 100,100 0 1,1 200,0 a 100,100 0 1,1 -200,0" />
    <path id="Circle5" d="M 125, 200 a 75,75 0 1,1 150,0 a 75,75 0 1,1 -150,0" />
    <path id="Circle6" d="M 150, 200 a 50,50 0 1,1 100,0 a 50,50 0 1,1 -100,0" />
    <path id="Circle7" d="M 175, 200 a 25,25 0 1,1 50,0 a 25,25 0 1,1 -50,0" />
  </defs>
  <text id="Text1">
    <textPath href="#Circle1">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text2">
    <textPath href="#Circle2">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text3">
    <textPath href="#Circle3">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text4">
    <textPath href="#Circle4">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text5">
    <textPath href="#Circle5">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text6">
    <textPath href="#Circle6">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text7">
    <textPath href="#Circle7">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text8">
    <textPath href="#Circle8">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text9">
    <textPath href="#Circle9">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
</svg>

徳、積みたいですよね。

ご存知マニ車。お寺とかにたまにある、周囲にマントラが書いてあって手で回すと1回転毎に1回お経を読んだのと同じ徳を積めるスピリチュアルグッズです。<sup>[<a target="_blank" href="https://www.amazon.co.jp/gp/search?ie=UTF8&tag=nishidemasami-22&linkCode=ur2&linkId=d1ba0bb31ef3d317b4a5c8ad6af3095d&camp=247&creative=1211&index=aps&keywords=マニ車">参考</a>]</sup>  
チベット仏教が国教であるブータンでは、水力マニ車や風力マニ車、ソーラーマニ車<sup>[<a target="_blank" href="https://www.amazon.co.jp/gp/search?ie=UTF8&tag=nishidemasami-22&linkCode=ur2&linkId=d1ba0bb31ef3d317b4a5c8ad6af3095d&camp=247&creative=1211&index=aps&keywords=ソーラーマニ車">参考</a>]</sup>などもあり、マニ車も進化しているということがわかります。[^1]

[^1]: 日本風力エネルギー学会誌 Vol.44, No.4

ならば、SVGとCSSでマントラを回しても徳が積めるのでは…？  
そう思ったので自分用にメモです。

```html
<style>
  #Text1{animation: spin 11s linear infinite; transform-origin: center;}
  #Text2{animation: spin 10s linear infinite; transform-origin: center;}
  #Text3{animation: spin 9s linear infinite; transform-origin: center;}
  #Text4{animation: spin 8s linear infinite; transform-origin: center;}
  #Text5{animation: spin 7s linear infinite; transform-origin: center;}
  #Text6{animation: spin 6s linear infinite; transform-origin: center;}
  #Text7{animation: spin 5s linear infinite; transform-origin: center;}
  #Text8{animation: spin 4s linear infinite; transform-origin: center;}
  #Text9{animation: spin 3s linear infinite; transform-origin: center;}
</style>
<svg style="max-width:400px" viewBox="0 0 400 400" >
  <defs>
    <path id="Circle1" d="M 25, 200 a 175,175 0 1,1 350,0 a 175,175 0 1,1 -350,0" />
    <path id="Circle2" d="M 50, 200 a 150,150 0 1,1 300,0 a 150,150 0 1,1 -300,0" />
    <path id="Circle3" d="M 75, 200 a 125,125 0 1,1 250,0 a 125,125 0 1,1 -250,0" />
    <path id="Circle4" d="M 100, 200 a 100,100 0 1,1 200,0 a 100,100 0 1,1 -200,0" />
    <path id="Circle5" d="M 125, 200 a 75,75 0 1,1 150,0 a 75,75 0 1,1 -150,0" />
    <path id="Circle6" d="M 150, 200 a 50,50 0 1,1 100,0 a 50,50 0 1,1 -100,0" />
    <path id="Circle7" d="M 175, 200 a 25,25 0 1,1 50,0 a 25,25 0 1,1 -50,0" />
  </defs>
  <text id="Text1">
    <textPath href="#Circle1">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text2">
    <textPath href="#Circle2">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text3">
    <textPath href="#Circle3">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text4">
    <textPath href="#Circle4">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text5">
    <textPath href="#Circle5">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text6">
    <textPath href="#Circle6">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text7">
    <textPath href="#Circle7">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text8">
    <textPath href="#Circle8">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
  <text id="Text9">
    <textPath href="#Circle9">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
  </text>
</svg>
```

このような感じで円のパスを複数個作って、それぞれを違う速さで回しています。

なお、以下のようにSVGのanimateTransformで回転させることもできます。  
しかし、CPUレンダリングになってしまうのでちょっとカクカクするので今回はこの方法は使いませんでした。


<svg style="max-width:400px" viewBox="0 0 400 400" >
  <defs>
    <path id="Circle1" d="M 25, 200 a 175,175 0 1,1 350,0 a 175,175 0 1,1 -350,0" />
    <path id="Circle2" d="M 50, 200 a 150,150 0 1,1 300,0 a 150,150 0 1,1 -300,0" />
    <path id="Circle3" d="M 75, 200 a 125,125 0 1,1 250,0 a 125,125 0 1,1 -250,0" />
    <path id="Circle4" d="M 100, 200 a 100,100 0 1,1 200,0 a 100,100 0 1,1 -200,0" />
    <path id="Circle5" d="M 125, 200 a 75,75 0 1,1 150,0 a 75,75 0 1,1 -150,0" />
    <path id="Circle6" d="M 150, 200 a 50,50 0 1,1 100,0 a 50,50 0 1,1 -100,0" />
    <path id="Circle7" d="M 175, 200 a 25,25 0 1,1 50,0 a 25,25 0 1,1 -50,0" />
  </defs>
  <text>
    <textPath href="#Circle1">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="11s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle2">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="10s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle3">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="9s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle4">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="8s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle5">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="7s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle6">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="6s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle7">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="5s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle8">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="4s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle9">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="3s" repeatCount="indefinite" />
  </text>
</svg>

```xml
<svg style="max-width:400px" viewBox="0 0 400 400" >
  <defs>
    <path id="Circle1" d="M 25, 200 a 175,175 0 1,1 350,0 a 175,175 0 1,1 -350,0" />
    <path id="Circle2" d="M 50, 200 a 150,150 0 1,1 300,0 a 150,150 0 1,1 -300,0" />
    <path id="Circle3" d="M 75, 200 a 125,125 0 1,1 250,0 a 125,125 0 1,1 -250,0" />
    <path id="Circle4" d="M 100, 200 a 100,100 0 1,1 200,0 a 100,100 0 1,1 -200,0" />
    <path id="Circle5" d="M 125, 200 a 75,75 0 1,1 150,0 a 75,75 0 1,1 -150,0" />
    <path id="Circle6" d="M 150, 200 a 50,50 0 1,1 100,0 a 50,50 0 1,1 -100,0" />
    <path id="Circle7" d="M 175, 200 a 25,25 0 1,1 50,0 a 25,25 0 1,1 -50,0" />
  </defs>
  <text>
    <textPath href="#Circle1">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="11s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle2">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="10s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle3">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="9s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle4">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="8s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle5">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="7s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle6">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="6s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle7">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="5s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle8">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="4s" repeatCount="indefinite" />
  </text>
  <text>
    <textPath href="#Circle9">ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ ॐ मणिपद्मे हूँ</textPath>
    <animateTransform attributeName="transform" attributeType="XML" type="rotate" from="0 200,200" to="360 200,200" dur="3s" repeatCount="indefinite" />
  </text>
</svg>
```

SVG単体でanimateTransformを利用してマニ車を回すより、CSSのanimationで回した方がスムーズな動作で回せました。

これでパソコンでもスマホでも、いつでもどこでも誰でも自動でスマートに徳を積めますね。  
以上、SVGで徳を積んだという話でした。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Google ColaboratoryでGitHubのipynbファイルを開く]]></title>
            <link>https://nishidemasami.github.io/posts/google-colab-github</link>
            <guid>https://nishidemasami.github.io/posts/google-colab-github</guid>
            <pubDate>Fri, 02 Dec 2022 20:58:43 GMT</pubDate>
            <description><![CDATA[Google ColaboratoryでGitHubのipynbファイルを開いてみたいと思うこと、ありますよね。僕はあるので自分用にメモです。]]></description>
            <content:encoded><![CDATA[
Google ColaboratoryでGitHubのファイルを開いてみたいと思うこと、ありますよね。  
僕はあるので自分用にメモです。

と言っても簡単で、GitHubでパブリックのリポジトリにファイルをコミットするだけです。

<https://github.com/nishidemasami/google-colab-tutorial/blob/main/ubuntu-command/useful_tools.ipynb>

このようなパスにコミットしたとしたら、

<https://colab.research.google.com/github/nishidemasami/google-colab-tutorial/blob/main/ubuntu-command/useful_tools.ipynb>

こうやってGoogle Colaboratoryで開くことができます。

簡単！
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Next.jsで数式を書く]]></title>
            <link>https://nishidemasami.github.io/posts/nextjs-latex</link>
            <guid>https://nishidemasami.github.io/posts/nextjs-latex</guid>
            <pubDate>Fri, 25 Nov 2022 19:58:43 GMT</pubDate>
            <description><![CDATA[Next.jsで数式を書いてみたいと思うこと、ありますよね。僕はあるので自分用にメモです。]]></description>
            <content:encoded><![CDATA[
Next.jsで数式を書いてみたいと思うこと、ありますよね。  
僕はあるので自分用にメモです。

2次方程式の解の公式、懐かしいですね。

$$
x = \frac{-b\pm\sqrt{b^2-4ac}}{2a}
$$

これを見ると学生時代を思い出しますね。  
こういう数式を、Next.jsでもMarkdownに$\LaTeX$で

```latex
x = \frac{-b\pm\sqrt{b^2-4ac}}{2a}
```

こんな感じで書けたら便利です。

今回は$\LaTeX$をウェブブラウザで表示するためのライブラリである$\KaTeX$をNext.jsで使ってみました。<sup>[<a target="_blank" href="https://www.amazon.co.jp/React-js%EF%BC%86Next-js%E8%B6%85%E5%85%A5%E9%96%80-%E7%AC%AC2%E7%89%88-%E6%8E%8C%E7%94%B0%E6%B4%A5%E8%80%B6%E4%B9%83-ebook/dp/B08XBNGYVH?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&crid=1304MCUGBPN1M&keywords=next.js&qid=1670505884&sprefix=next.j%2Caps%2C195&sr=8-6&linkCode=ll1&tag=nishidemasami-22&linkId=1faf1c568d048e662fff7bffcc7794e3&language=ja_JP&ref_=as_li_ss_tl">参考文献</a>]</sup>

JavaScriptで動的にブラウザ上で数式を描画するのがよく見る$\KaTeX$の使い方ですが、Next.jsでSSGしている時にはビルド時に既に数式がHTMLにレンダリング済みだという挙動になるので少し仕組みが違います。  
ブラウザとしては$\LaTeX$形式の数式をHTMLへ変換する必要がなくなり描画が高速だという点がメリットです。ブラウザがJavaScriptを無効化していても見れるのもいいですね。

まず、必要なパッケージをインストールします。

```bash
npm install remark-math rehype-katex
```

このウェブサイトではMarkdownを読み込むのに _unified_ を使用しているので、 _remark-math_ と _rehype-katex_ を追加で _use_ します。

```typescript
import rehypePrism from '@mapbox/rehype-prism';
import rehypeKatex from 'rehype-katex';
import rehypeStringify from 'rehype-stringify';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import remarkParse from 'remark-parse';
import remarkRehype from 'remark-rehype';
import { unified } from 'unified';

export const markdownToHtml = async (markdown: string) =>
  (
    await unified()
      .use(remarkParse)
      .use(remarkMath)
      .use(remarkGfm)
      .use(remarkRehype, { allowDangerousHtml: true })
      .use(rehypePrism)
      .use(rehypeKatex)
      .use(rehypeStringify, { allowDangerousHtml: true })
      .process(markdown)
  )
    .toString();
```

あとは$\KaTeX$のCSSをCDNなどから読み込めば完成です。

```html
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" crossOrigin="anonymous" />
```

では、実際に書いてみることにします。  
以下は任意の$x$と$y$の最大公約数を求める$gcd$関数の定義です。

```latex
\gcd(x, y) =
\begin{cases}
  y & (x = 0)\\
  x & (y = 0)\\
  \gcd(y, x \bmod y) & (\text{otherwize})
\end{cases}
```

$$
\gcd(x, y) =
\begin{cases}
  y & (x = 0)\\
  x & (y = 0)\\
  \gcd(y, x \bmod y) & (\text{otherwize})
\end{cases}
$$

上手に書けました！✨

以上です。  
<https://github.com/nishidemasami/nishidemasami.github.io>  
実際にNext.jsで動いているコードは👆ここから確認してください。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ED25519の鍵を生成する]]></title>
            <link>https://nishidemasami.github.io/posts/gen_ed25519_key</link>
            <guid>https://nishidemasami.github.io/posts/gen_ed25519_key</guid>
            <pubDate>Sat, 19 Nov 2022 14:02:43 GMT</pubDate>
            <description><![CDATA[ED25519の鍵を生成したいこと、ありますよね。僕はあるので自分用にメモです。]]></description>
            <content:encoded><![CDATA[
もう1年以上前にAWSでED25519の鍵が使えるようになっていた。  
当然のようにGitHubでも使える。  
どんどんED25519を使えない環境もかなり減ってきていて、ED25519の鍵を作る機会も増えてきた。

なのに、ED25519の鍵の作り方をいつもググって調べるので自分用にメモ。

`ssh-keygen -t ed25519`  
で作成できる。  

```bash
$ ssh -V
OpenSSH_8.9p1 Ubuntu-3, OpenSSL 3.0.2 15 Mar 2022
$ ssh-keygen -t ed25519
Generating public/private ed25519 key pair.
Enter file in which to save the key (/home/nishidemasami/.ssh/id_ed25519):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/nishidemasami/.ssh/id_ed25519
Your public key has been saved in /home/nishidemasami/.ssh/id_ed25519.pub
The key fingerprint is:
SHA256:mObF7QvcCUg1/JQb9aF6hc2R6GCuu7UpYipZ03J6Xtw nishidemasami@desktop-nishidemasami
The key's randomart image is:
+--[ED25519 256]--+
|       .o  o..o. |
|       ...* .*.o |
|      .  = =o =  |
|     . = .+...   |
|     .= S.o .    |
|    +oo+.= o     |
|   o =. =.E      |
|  o . +.oo +     |
|   ..=...o+      |
+----[SHA256]-----+
```

参考
<https://aws.amazon.com/jp/about-aws/whats-new/2021/08/amazon-ec2-customers-ed25519-keys-authentication/>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[GitHubのレポジトリサイズを確認する]]></title>
            <link>https://nishidemasami.github.io/posts/check_github_repository_size</link>
            <guid>https://nishidemasami.github.io/posts/check_github_repository_size</guid>
            <pubDate>Sat, 12 Nov 2022 14:02:43 GMT</pubDate>
            <description><![CDATA[GitHubのレポジトリサイズを確認する]]></description>
            <content:encoded><![CDATA[
リポジトリのサイズがいつも気になるので自分用にメモ。

`https://api.github.com/repos/アカウント名/リポジトリ名`  
にアクセスするとjsonで詳細が取得できる。  
その`size`にKB単位でサイズが入っている。

たとえば`github.com:nishidemasami/nishidemasami.github.io.git`の場合、  
<https://api.github.com/repos/nishidemasami/nishidemasami.github.io>  
このURLで取得できる。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Next.jsでこのウェブサイトをリニューアルしました！✨]]></title>
            <link>https://nishidemasami.github.io/posts/nextjs-website-renewal</link>
            <guid>https://nishidemasami.github.io/posts/nextjs-website-renewal</guid>
            <pubDate>Fri, 04 Nov 2022 16:04:03 GMT</pubDate>
            <description><![CDATA[Next.jsでこのウェブサイトをリニューアルしました！✨]]></description>
            <content:encoded><![CDATA[
Next.jsでこのウェブサイトをリニューアルしました！✨

T3 Stackの6つの技術のうち、フロントエンド側の以下の3つの技術をフル活用しています。

* TypeScript<sup>[<a target="_blank" href="https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0TypeScript-%E2%80%95%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8BJavaScript%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E9%96%8B%E7%99%BA-Boris-Cherny/dp/4873119049?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&crid=3Q7MI7KXY06BB&keywords=typescript&qid=1670505807&sprefix=typescript+%2Caps%2C224&sr=8-9&linkCode=ll1&tag=nishidemasami-22&linkId=48539012d76c58e8bc3549b5a9dc7a1f&language=ja_JP&ref_=as_li_ss_tl" rel="noreferrer" >参考文献</a>]</sup>  
ほぼ全てTypeScriptで書いています。
* Next.js  
SSGフレームワークに使用しています。
* Tailwind CSS  
スタイルを書くのに使用しています。CSSもSCSSもstyled-componentsもどうしても必要な箇所を除けば使っていません。

また、リニューアル後も引き続きGitHub ActionsでCI/CDを継続しています。

今のところこのウェブサイトはNext.jsになる前には、

Hexo  
🔽  
Gatsby.js  
🔽  
Next.js

という偏移を経ています。

Hexoは純粋な時代の古き良きSSGでした。しかしパフォーマンスを追い求めると限界がありました。  
Gatsby.jsは _Blazing fast🔥_ ではあったもののちょっとカスタマイズしようとするとすぐgatsby-pluginが必要になりました。  
その点Next.jsは、何もかも自分でコントロールできるような確かな手触りを感じています。  
それにNext.jsも十分速い。とにかくウェブサイトのなにをクリックしても速いです。普通の使い方をするならGatsby.jsと違いがわからないほど速いです。  

Next.jsをもっと良く知るためにも、引き続きこのウェブサイトでいろいろなことをやってみようと思っています。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SVGとCSSだけで文字をクルクル回す]]></title>
            <link>https://nishidemasami.github.io/posts/css-svg-rotate-text</link>
            <guid>https://nishidemasami.github.io/posts/css-svg-rotate-text</guid>
            <pubDate>Tue, 16 Mar 2021 16:04:03 GMT</pubDate>
            <description><![CDATA[JavaScriptを使わずにSVGとCSSだけで文字をクルクル回したいこと、ありますよね。僕はあるので自分用にメモです。]]></description>
            <content:encoded><![CDATA[
JavaScriptを使わずにSVGとCSSだけで文字をクルクル回したいこと、ありますよね。  
僕はあるので自分用にメモです。

<svg style="animation: spin 5s linear infinite; max-width:300px" viewBox="0 0 100 100" >
  <defs>
    <path id="Circle" d="M 25, 50 a 25,25 0 1,1 50,0 a 25,25 0 1,1 -50,0" />
  </defs>
  <text>
    <textPath href="#Circle">文字がクルクル回ります。</textPath>
  </text>
</svg>

```html
<svg
  style="animation: spin 5s linear infinite; max-width:300px"
  viewBox="0 0 100 100"
>
  <defs>
    <path
      id="Circle"
      d="M 25, 50 a 25,25 0 1,1 50,0 a 25,25 0 1,1 -50,0"
    />
  </defs>
  <text>
    <textPath href="#Circle">
      文字がクルクル回ります。
    </textPath>
  </text>
</svg>
```

SVGは大きさ50*50の円とその周囲を沿うようにテキストを記述しています。SVGのスタイルにはクルクル回るCSSを書いてます。  
これだけでクルクル回ったので楽しかったです。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Reactでホワイトノイズを鳴らす]]></title>
            <link>https://nishidemasami.github.io/articles/react-sound-test</link>
            <guid>https://nishidemasami.github.io/articles/react-sound-test</guid>
            <pubDate>Sat, 13 Mar 2021 16:04:03 GMT</pubDate>
            <description><![CDATA[Reactでホワイトノイズを鳴らしたいこと、ありますよね。僕はあるので自分用にメモです。]]></description>
            <content:encoded><![CDATA[*/

import React from 'react';

import { format } from 'date-fns';
import { GetStaticProps } from 'next';
import Link from 'next/link';

import { ReactAudioTest } from '../../components/ReactAudioTest';
import { Content } from '../../content/Content';
import { Meta } from '../../layout/Meta';
import { PostPagination } from '../../pagination/PostPagination';
import { Main } from '../../templates/Main';
import {
	getPrevNextPost,
	getRecentPosts,
	getTags,
	PostItems,
} from '../../utils/Content';
import { markdownToHtml } from '../../utils/Markdown';

type ReactSoundTestProps = {
	recents: PostItems[];
	tags: string[];
	sorceCodeHTML: string;
	prevPost?: PostItems;
	nextPost?: PostItems;
};

const sorceCodeMarkdown = `
\`\`\`typescript
import React from 'react';

import { VolumeDown, VolumeUp } from '@mui/icons-material';
import { Button, CircularProgress, Grid, Slider } from '@mui/material';

// webkit用Typescript型宣言
declare global {
  interface Window {
    webkitAudioContext: AudioContext;
  }
}

const ReactAudioTest: React.FunctionComponent = () => {
  // 音量：初期値25
  const [volume, setVolume] = React.useState(25);
  // 再生状態：初期値false
  const [playingFlag, setPlayingFlag] = React.useState(false);
  // AudioContext：初期値undefined
  const [audioContext, setAudioContext] = React.useState<
    AudioContext | undefined
  >(undefined);
  // 音源ソース：初期値undefined
  const [source, setSourceState] = React.useState<
    AudioBufferSourceNode | undefined
  >(undefined);
  // 音量調節：初期値undefined
  const [gainState, setGainState] = React.useState<GainNode | undefined>(
    undefined
  );

  React.useEffect(() => {
    // 初期化
    const newAudioContext = new (window.AudioContext ||
      window.webkitAudioContext)();
    setAudioContext(newAudioContext);
    const gainNode = newAudioContext.createGain();
    gainNode.gain.value = volume / 100;
    setGainState(gainNode);

    return () => {
      // unmount時の後始末
      if (source) {
        source.buffer = null; // メモリリーク防止
      }
      if (newAudioContext) {
        newAudioContext.close();
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  React.useEffect(() => {
    // 音量変更
    if (gainState) {
      gainState.gain.value = volume / 100;
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [volume]);

  // スマホなどでは迷惑な自動再生を防ぐ目的で
  // ユーザの操作に伴う再生でしか音を再生できない
  const onClickToStartAndStop = React.useCallback(() => {
    if (audioContext && gainState) {
      if (playingFlag) {
        // 停止
        if (source) {
          source.stop();
          source.buffer = null; // メモリリーク防止
        }
      } else {
        // 再生
        const channels = 1; // モノラル
        const frameCount = audioContext.sampleRate * 2.0; // 2秒

        const myArrayBuffer = audioContext.createBuffer(
          channels,
          frameCount,
          audioContext.sampleRate
        );

        for (let channel = 0; channel < channels; channel += 1) {
          // ホワイトノイズ生成
          const nowBuffering = myArrayBuffer.getChannelData(channel);
          for (let i = 0; i < frameCount; i += 1) {
            nowBuffering[i] = Math.random() * 2 - 1;
          }
        }
        const buffersource = audioContext.createBufferSource();
        setSourceState(buffersource);
        buffersource.buffer = myArrayBuffer;
        buffersource.loop = true;
        buffersource.connect(gainState).connect(audioContext.destination);
        buffersource.start();
      }
      setPlayingFlag(!playingFlag);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [playingFlag, audioContext, gainState]);

  if (!audioContext || !gainState) {
    return (
      <React.Fragment>
        <CircularProgress />
        loading...
      </React.Fragment>
    );
  }

  return (
    <div className="text-center h-fit w-full">
      <Grid container>
        <Grid item></Grid>
        <Grid item>
          <VolumeDown />
        </Grid>
        <Grid item xs={10}>
          <Slider
            min={0}
            max={100}
            defaultValue={50}
            value={volume}
            onChange={(__, newValue) => {
              if (typeof newValue === 'number') {
                setVolume(newValue);
              }
            }}
            valueLabelDisplay="auto"
            aria-labelledby="continuous-slider"
          />
        </Grid>
        <Grid item>
          <VolumeUp />
        </Grid>
        <Grid item></Grid>
      </Grid>

      <Button
        variant="outlined"
        color={playingFlag ? 'info' : 'primary'}
        onClick={onClickToStartAndStop}
      >
        ホワイトノイズ{playingFlag ? '停止' : '再生'}
      </Button>
    </div>
  );
};

export { ReactAudioTest };
\`\`\`
`;

const ReactSoundTest = (props: ReactSoundTestProps) => (
	<Main
		recents={props.recents}
		tags={props.tags}
		meta={
			<Meta
				title="Reactでホワイトノイズを鳴らす"
				description="React + TypeScript でホワイトノイズを鳴らしてみました"
			/>
		}
	>
		<h1 className="text-center font-bold text-3xl text-gray-900">
			Reactでホワイトノイズを鳴らす
		</h1>
		<div className="text-center text-sm mb-4">
			{format(new Date('2021-03-14T01:04:03+0900'), 'LLLL d, yyyy')}
		</div>
		<ul className="flex flex-row flex-wrap list-none p-0 m-2 justify-start">
			{['TypeScript', 'React'].map((tag) => (
				<li
					className="px-2 py-1 m-1 rounded-full overflow-hidden shadow-md border-0 bg-white w-fit break-all"
					key={tag}
				>
					<Link href="/tag/[tag]" as={`/tag/${tag}`}>
						#{tag}
					</Link>
				</li>
			))}
		</ul>

		<Content>
			<div>
				<p>
					Reactでホワイトノイズを鳴らしたいこと、ありますよね。
					<br />
					僕はあるので自分用にメモです。
				</p>
				<p>
					↓ React + TypeScript でホワイトノイズを鳴らしてみました。
					<sup>
						[
						<a
							target="_blank"
							href="https://www.amazon.co.jp/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0TypeScript-%E2%80%95%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8BJavaScript%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E9%96%8B%E7%99%BA-Boris-Cherny/dp/4873119049?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&crid=3Q7MI7KXY06BB&keywords=typescript&qid=1670505807&sprefix=typescript+%2Caps%2C224&sr=8-9&linkCode=ll1&tag=nishidemasami-22&linkId=48539012d76c58e8bc3549b5a9dc7a1f&language=ja_JP&ref_=as_li_ss_tl"
							rel="noreferrer"
						>
							参考文献
						</a>
						]
					</sup>
					<br />
					※音が鳴ります
				</p>
				<ReactAudioTest />
				<p>
					パソコンで音を鳴らすのはかんたんなんですけどスマホはガードが固いらしくて、ユーザのなんらかの動作をトリガーとして再生しないと再生されないみたいです。
				</p>
				<p>なので今回は useCallback で宣言して onClick から呼びました。</p>
				<p>↓ これが今回のコードです</p>
				<div dangerouslySetInnerHTML={{ __html: props.sorceCodeHTML }} />
			</div>
		</Content>

		<PostPagination nextPost={props.nextPost} prevPost={props.prevPost} />
	</Main>
);

export const getStaticProps: GetStaticProps<ReactSoundTestProps> = async () => {
	const recents = getRecentPosts(['title', 'date', 'slug']);

	return {
		props: {
			recents,
			tags: getTags(),
			sorceCodeHTML: await markdownToHtml(sorceCodeMarkdown),
			...getPrevNextPost(__filename),
		},
	};
};

export default ReactSoundTest;
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Gatsbyでブログをリニューアルしてみました]]></title>
            <link>https://nishidemasami.github.io/articles/blog-remake-with-gatsby</link>
            <guid>https://nishidemasami.github.io/articles/blog-remake-with-gatsby</guid>
            <pubDate>Sat, 06 Mar 2021 09:04:03 GMT</pubDate>
            <description><![CDATA[このブログをリニューアルしてみました。このブログのソースはここ ↓ で公開しています。https://github.com/nishidemasami/nishidemasami.github.io/tree/gatsby見てみた感じどうですか？すごくないですか！？…]]></description>
            <content:encoded><![CDATA[*/

import React from 'react';

import { format } from 'date-fns';
import { GetStaticProps } from 'next';
import Link from 'next/link';

import ReactHelloWorld from '../../components/ReactHelloWorld/ReactHelloWorld';
import { Content } from '../../content/Content';
import { Meta } from '../../layout/Meta';
import { PostPagination } from '../../pagination/PostPagination';
import { Main } from '../../templates/Main';
import {
	getPrevNextPost,
	getRecentPosts,
	getTags,
	PostItems,
} from '../../utils/Content';

type AboutProps = {
	recents: PostItems[];
	tags: string[];
	prevPost?: PostItems;
	nextPost?: PostItems;
};

const About = (props: AboutProps) => (
	<Main
		recents={props.recents}
		tags={props.tags}
		meta={
			<Meta
				title="Gatsbyでブログをリニューアルしてみました"
				description="Gatsbyでブログをリニューアルしてみました"
			/>
		}
	>
		<h1 className="text-center font-bold text-3xl text-gray-900">
			Gatsbyでブログをリニューアルしてみました
		</h1>
		<div className="text-center text-sm mb-4">
			{format(new Date('2021-03-06T18:04:03+0900'), 'LLLL d, yyyy')}
		</div>
		<ul className="flex flex-row flex-wrap list-none p-0 m-2 justify-start">
			{['JavaScript', 'TypeScript', 'React', 'Gatsby'].map((tag) => (
				<li
					className="px-2 py-1 m-1 rounded-full overflow-hidden shadow-md border-0 bg-white w-fit break-all"
					key={tag}
				>
					<Link href="/tag/[tag]" as={`/tag/${tag}`}>
						#{tag}
					</Link>
				</li>
			))}
		</ul>
		<Content>
			<div>
				<p>
					このブログをリニューアルしてみました。
					ちなみにこのブログのソースはここ ↓ で公開しています。
					<a href="https://github.com/nishidemasami/nishidemasami.github.io/tree/gatsby">
						https://github.com/nishidemasami/nishidemasami.github.io/tree/gatsby
					</a>
				</p>
				<p>作ってみた感じ、すごくいいと思います！</p>
				<ul>
					<li>React が動いている・生で React が書ける</li>
					<li>
						ページ間の遷移の速度が速い(React の仮想 DOM 操作に由来している)
					</li>
					<li>
						ちょっとがんばれば Typescript でも書ける(使用する Gatsby
						のテンプレートによっては最初から Typescript を使っているらしい)
					</li>
					<li>
						Gatsby が静的にページを作ってくれているので Javascript
						をオフにしてても見れる
					</li>
				</ul>

				<ReactHelloWorld>
					こんな感じで普通にReact が<br />
					Typescript で書けて動きます！✨
				</ReactHelloWorld>
				<p>
					Gatsby は、HEXO や Hugo、Jekyll
					みたいに静的ジェネレータなので、こうやって Github Pages
					にも乗せられるので便利！ AWS S3 とかに乗せればスケールしますし！✨
				</p>
				<p>
					あと、ページを高速化するための細かなテクニックを最初から使ってくれています。
				</p>
				<ul>
					<li>静的プレレンダリング・静的プリフェッチ(速い)</li>
					<li>
						いわゆる PRPL パターンに準拠する PWA サポート
						<br />
						<strong>
							<em>Push </em>
						</strong>
						critical resources for the initial URL route using
						<code>&lt;link preload&gt;</code> and HTTP/2.
						<br />
						<strong>
							<em>Render </em>
						</strong>
						initial route.
						<br />
						<strong>
							<em>Pre-cache </em>
						</strong>
						remaining routes.
						<br />
						<strong>
							<em>Lazy-load </em>
						</strong>
						and create remaining routes on demand.
						<br />
						<a href="https://www.gatsbyjs.com/docs/prpl-pattern/">
							https://www.gatsbyjs.com/docs/prpl-pattern/
						</a>
					</li>
					<li>
						GraphQL(ビルド時には json
						になっている)によるデータアクセスや画面遷移(これまた速い)
					</li>
				</ul>
				<p>
					Gatsby で Markdown ファイルとかいい感じにしてくれますし、普通に React
					の仮想 DOM による高速化の恩恵も受けることできてます！
					かなりいい感じになってると思います！✨
				</p>
			</div>
		</Content>

		<PostPagination nextPost={props.nextPost} prevPost={props.prevPost} />
	</Main>
);

export const getStaticProps: GetStaticProps<AboutProps> = async () => ({
	props: {
		recents: getRecentPosts(['title', 'date', 'slug']),
		tags: getTags(),
		...getPrevNextPost(__filename),
	},
});

export default About;
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ネットワークスペシャリスト合格体験記]]></title>
            <link>https://nishidemasami.github.io/posts/network-specialist-examination</link>
            <guid>https://nishidemasami.github.io/posts/network-specialist-examination</guid>
            <pubDate>Sun, 18 Dec 2016 09:04:03 GMT</pubDate>
            <description><![CDATA[念願のネットワークスペシャリストに合格しました！本当に念願で、というのも情報セキュリティスペシャリスト合格から今回で丸 2 年経っていて、今回合格できなければ午前 I 免除が終わってしまうところだったんです。…]]></description>
            <content:encoded><![CDATA[
念願のネットワークスペシャリストに合格しました！
本当に念願で、というのも情報セキュリティスペシャリスト合格から今回で丸 2 年経っていて、今回合格できなければ午前 I 免除が終わってしまうところだったんです。

こちらが成績です。

![ネットワークスペシャリスト成績](https://lh3.googleusercontent.com/pw/ACtC-3cJJG24p8M5wNBDBcGb4Bmc0njr2p2GzTuXB3z_7vwnC0FyW8ChvDTKkOH5SFB1fqS6jiFCkysXD53sSs5OOZ_67KRgHwIJ-vH_Pg6XSFM2JSZmDplgXH-WgtqPZRQ9qG9D7g59rYN7efbAoiJILXnnmA=w563-h351-no?authuser=0)
60 点が合格ラインなので、ゆとりを持った合格となりました！

2 年前の情報セキュリティスペシャリストの時は午前 I 免除、午前 II が 84 点、午後 I が 71 点、午後 II が 62 点と午後 II がギリギリでした。
しかし今回は、午前 I が同じく免除で、午前 II が 72 点、午後 I が 70 点、午後 II が 72 点でした。いずれも 7 割超です！
では今回のネットワークスペシャリストが余裕だったかと言うとそうではなく、今回も非常に厳しい戦いとなりました。

今後ネットワークスペシャリストに挑戦するみなさんの助けになるよう、自分の今回の勉強法を書いていきたいと思います。

### 良い教本に出会う

僕はネットワークスペシャリストに合格するのに 2 年かかりました。
長い間お付き合いする本ですから、教本選びは大切です。
僕は、定番のポケットスタディで勉強しました。「ポケットスタディ ネットワークスペシャリスト」で検索すれば出てくると思います。
コンパクトなのでいつでも持ち歩けますし、外出先でも気軽に読めて便利です。
ポケットスタディだけで基礎を完璧にはできないかもしれませんが、必要知識のリストアップとして効果的です。
不足知識や理解しきれない部分はネットで調べました。
ネットとポケットスタディで、常に勉強ができる状態を維持するところがポイントです。

また、過去問の解答の解説にはネスペの剣なども読みました。
問題・解答は無料で公式サイトからダウンロードできますが、解説は別に必要です。
ただ、解説本に手を出すのもおそらく基礎を身に付けてからの話だと思います。
それに、基礎を身につける間にネットでわからないところを検索していると、いつの間にか解説なしでも問題を読めるようになっているものです。
ちなみに僕は BGP や OSPF などがピンと来ないのでそこらへんは本に頼りました。

それから、これまた定番の「3 Minutes Networking([http://www5e.biglobe.ne.jp/aji/3min/](http://www5e.biglobe.ne.jp/aji/3min/))」もオススメです。
ネットワーク技術をある程度体系的にまとめて教えてくれる貴重なサイトです。しかも 1 講座 3 分で読めるのだそうです(※読めません！)。
ぜひ読破に挑戦してみましょう！

### 新しい技術を学ぶ

データベーススペシャリストは、新しい技術はあまり出てきません。出てきて NoSQL くらいです。データベーススペシャリストは話のわかるヤツです。
けどネットワークスペシャリストはそんなの気にしません。
今回、午後 II では STUN や WebRTC が問題に登場しました。
WebSocket や、過去には OpenFlow も出ています。
2013 年なんて午後 II の問 2 が丸々 OpenFlow だったので、OpenFlow をノーチェックだった人は問 1 しか選択肢が無く非常に不利な戦いとなったはずです。
今こうしている間にも新しい技術はどんどん出現していますので、後学のためにも話題の新技術は怯まずぜひチェックしてゆきましょう。

### 確実に基礎を固める

上に書いたことと関連するのですが、新技術を学ぶことは、当然基礎を固めることから始まります。
新技術もおおむね基礎の上に成り立っています。既存の技術をパッケージした AJAX のような例もありますし、また問題によっては、わからない技術がちょこっとあったとしても基礎ができていれば解ける問題もあります。
ネットワークスペシャリスト試験はネットワーク技術に絞った試験…と言われる範囲は狭いと思われがちですが、実際の所、ネットワーク技術がクライアントからサーバ、バックボーン、セキュリティまでも出るので範囲は広いです。ホントに途方もない範囲です。
しかし、だいたいのネットワークは TCP/IP の上で動いているので TCP/IP さえ理解すれば問題文から解ける時もあります。
試験問題は意外にも親切丁寧に書かれていたりします。基礎を固めておくだけで、チャンスはぐっと広がります。
例えば今回受験した平成 28 年度から以下の問題です。

> 迷惑メールの送信を防止する対策として、OP25B(Outbound Port 25
> Blocking)のポリシでメールシステムを運用している。具体的には、自社が動的に割り当てた
> IP
> アドレスのホストから、自社のサービスネットワーク外のホストへの宛先ポート番号
> 25 の SMTP 通信を許可しないという運用上のルールを適用している。 (中略)B
> 社の PC から A 社のメールサーバへ SMTP
> によるメール送信ができたとしても、そのメールサーバは A
> 社のドメイン以外への宛先へはメールを転送しない設定となっている。
> この設定がないことによって生じる情報セキュリティ上のリスクを、25
> 字以内で答えよ (※平成 28 年度 ネットワークスペシャリスト試験午後 I
> 試験問題より引用・要約)

これは「第三者中継」に関する問題です。今時当たり前すぎて見逃しがちな「第三者中継」、だからなのか随分親切な問題文です。
「第三者中継」という概念を知らなくとも、これだけ丁寧に説明されていれば、基礎をわかっていれば答えられるはずです。
※もちろんこれは問題文から必要な箇所だけ抜きだしたものなので簡単そうに見えますが実際は何ページもある問題文からヒントを見つけなければいけません！

ちなみに解答は以下の通りです。

> 不正メールの踏み台にされてしまうリスク (※平成 28 年度
> ネットワークスペシャリスト試験午後 I 試験解答例より引用)

このように、基礎さえわかっていれば自力で解ける問題もあります。
それに基礎は実務では必須です。ぜひ幅広く身につけましょう。
iptables でルータを作ってみたり、Wireshark などで通信を覗いてみたりすると楽しいくて勉強にもなるのでおすすめです！

### 過去問の解答例を学ぶ

記述式の問題にはしばしば、なんて答えればいいか悩む問題があります。例えば同じく平成 28 年度から以下の問題です。

> ロードバランサは、通信の行きと戻りを同じ ISP
> 経由にするが、通信の行きと戻りが同じ ISP でない場合の問題を、社外から Web
> サーバへのアクセスを例に、IP アドレスという用語を用いて 40
> 文字以内で述べよ。 (※平成 28 年度 ネットワークスペシャリスト試験午後 II
> 試験問題より引用・要約)

さて、困りました。こんなこと聞かれては。
通信の行きと戻りで違う ISP でを使うと言われても、そんなことすればブラウザからホームページへアクセスしても、問い合わせしたところと全然違うところからレスポンスが横殴りで返ってくるわけです。
ESTABLISHED してないんですから、今時 NAPT やファイアーウォールでガチガチに守られている我々のブラウザには、戻りの通信は届きすらしなさそうです。
なんと答えればいいでしょうか？
「戻りの IP アドレスの通信がファイアーウォールで弾かれてしまう」でしょうか？
そもそも「戻りの通信の IP アドレスが ESTABLISHED していない」でしょうか？

解答を見てみましょう。

> 応答が行きの宛先 IP アドレスとは異なる送信元 IP アドレスから戻る。 (※平成
> 28 年度 ネットワークスペシャリスト試験午後 II 試験解答例より引用)

根本的！
そうなんです。解答に困ったら「で、実際のところなにが言いたいの？」というところを突き詰めてゆくと、自ずとシンプルな答えが出てくるはずです。
この問題は TCP/IP の知識があれば答えられますが、後半の問題は STUN も絡んできます。STUN ですよ！ワクワクしますよね？
ですがワクワクするからといって、例えば変に Skype 黎明期の苦労話などを知っていると「そもそも NAT 超えというのは〜〜」などと長々と講釈を書いてしまいそうになりますが、
それは心の中にそっと閉まっておくのが試験合格のため（そして普段の円滑な業務遂行のため）の秘訣です。
◯◯ 文字以内という解答に求められているレベル感を掴むためにも、過去問はぜひ 1 度解いてみましょう。なんていったって過去問は公式サイトからダウンロード無料です。

### 心を強く持つ

最後になりましたが！
諦めてはそこで試験終了です！
僕は過去に何度も試験中諦めそうになった問題を気合で解いてきました！そしてそのうち半分くらいは合格してました！
心を強く持って、挫けずにトライすることが大切です！
がんばりましょう！僕もがんばります！次は春はデータベーススペシャリスト、秋はシステムアーキテクトかもしくは IT ストラテジストを受ける予定です！

ネットワークスペシャリストに合格したという話でした！
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[hexoのテーマを変更した時に、テーマだけデプロイされない]]></title>
            <link>https://nishidemasami.github.io/posts/hexo-themes-error</link>
            <guid>https://nishidemasami.github.io/posts/hexo-themes-error</guid>
            <pubDate>Sun, 11 Dec 2016 14:04:03 GMT</pubDate>
            <description><![CDATA[このブログはHexoにて構築し、GitHub Pagesにて公開しています。先日、テーマを変更した際にテーマが正しく反映されず困ったので、今どうやって動いているかを覚え書きしておきます。…]]></description>
            <content:encoded><![CDATA[
このブログは[Hexo](https://hexo.io/)にて構築し、[GitHub Pages](https://pages.github.com/)にて公開しています。

先日、テーマを変更した際にテーマが正しく反映されず困ったので、今どうやって動いているかを覚え書きしておきます。

今回、ingenuous というテーマを利用したのですが、「hexo server」では正しく表示されるのに、確認後「hexo deploy -g」で GitHub Pages へデプロイするとレイアウトが崩れるという現象に見舞われました。

```bash
$ tree -L 2
.
├── _config.yml
├── node_modules
│   └── (省略)
├── package.json
├── public
│   ├── 2016
│   ├── about-me
│   ├── archives
│   ├── atom.xml
│   ├── css
│   ├── fancybox
│   ├── index.html
│   ├── js
│   └── tags
├── scaffolds
│   └── (省略)
├── source
│   └── _posts
└── themes
    ├── ingenuous
    └── landscape
```

この、css らへんがブラウザから取得できておらず、どうやら記事ファイルだけ書き換わってデプロイされ、css はデプロイされず放置されている現象が置きてるっぽかったです。
hexo deploy が public 内の更新を取得できていないのなら、全部消してしまえばいいじゃないということで、

```bash
hexo clean
hexo deploy -g
```

で無事にレイアウトも含めてデプロイすることができました。
ちょっとネットで検索しても出てこなかったのでみなさまの助けになればという意味も含め覚え書きでした。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Vimで暗号化]]></title>
            <link>https://nishidemasami.github.io/posts/vim-crypt</link>
            <guid>https://nishidemasami.github.io/posts/vim-crypt</guid>
            <pubDate>Sun, 04 Dec 2016 00:04:03 GMT</pubDate>
            <description><![CDATA[Vimで暗号化したいと思うこと、ありますよね。僕はあるので自分用にメモです。Vim で暗号化を行うには、次の方法が用意されています。:set cryptmethod=blowfishこの blowfish の他に zip や、環境によっては blowfish2 が用意されています。使えるならばセキュリティの面から考えて blowfish2 を使うべきでしょう。…]]></description>
            <content:encoded><![CDATA[
Vimで暗号化したいと思うこと、ありますよね。  
僕はあるので自分用にメモです。

Vim で暗号化を行うには、次の方法が用意されています。

```vim
:set cryptmethod=blowfish
```

この blowfish の他に zip や、環境によっては blowfish2 が用意されています。使えるならばセキュリティの面から考えて blowfish2 を使うべきでしょう。
しかしです。本当にセキュリティの面から考えると、blowfish の発展型である Twofish[※注：blowfish2 は Twofish ではありません](http://vim.1045645.n5.nabble.com/Blowfish2-td5726043.html)や AES 等の方がより良い選択肢なはずです。
今回、Vim の暗号化機能に頼らず、自前で openssl を用いて AES にて暗号化・復号をしてみたいと思います。

通常 vim で文章を保存するのには

```vim
:w
```

を行いますが、出力先を標準入力としてコマンドを実行することもできます。
すなわち、openssl へ以下のように渡せば良いわけです。

```vim
:w !openssl aes-256-cbc -out ~/vim_enc_test_file
```

2 回パスワードを聞かれるため、それを入力すれば指定した場所(この場合は~/vim_enc_test_file)へ書き込まれます。

復号する際は、Vim から

```vim
:r !openssl aes-256-cbc -d -in ~/vim_enc_test_file
```

とするか、もしくはコマンドラインから

```bash
cat ~/vim_enc_test_file | openssl aes-256-cbc -d | vim -
```

とします。

ただ、非常にイケてないことにこの書き込まれたファイルを text して見てみると、

```text
00000000  53 61 6c 74 65 64 5f 5f  04 12 0d 0c 9e e8 74 aa  |Salted__......t.|
00000010  f6 60 00 e7 d1 60 7b 64  19 23 a5 ad 7f 4d 62 19  |.`...`{d.#...Mb.|

```

このように、ファイルの頭に「Salted\_\_」の文字列が入るため、openssl にて暗号化したことはわかる人にはバレバレです。
もっとも、Vim の暗号化機能でも以下のように、

```text
00000000  56 69 6d 43 72 79 70 74  7e 30 32 21 de 8b b9 db  |VimCrypt~02!....|
00000010  03 c7 6b 23 86 e1 25 79  e7 ee 6c 5e 27 9d eb 58  |..k#..%y..l^'..X|
00000020  f8                                                |.|
```

「VimCrypt~02!」という文字列が入るのでバレバレなのですが。

このバレバレなのをどうにかしたい時も、openssl でやる場合は簡単です。
以下のように dd で 8 バイトスキップすれば「Salted\_\_」の文字列を消すことができます。

```vim
:w !openssl aes-256-cbc | dd ibs=8 skip=1 of=~/vim_enc_test_file
```

そうすると、以下のようなファイルが出力されます。

```text
00000000  92 3a 22 ce 3e 26 5a cf  26 6c da e5 3c ec e9 c6  |.:".>&Z.&l..<...|
00000010  ad 3b c1 47 13 d6 e9 d2                           |.;.G....|
```

当然、一見ランダムですから、ただの乱数ファイルにも見えますし、たとえ暗号化されたファイルだとわかったとしてもいったいなんのソフトで暗号化されたのかもわかりません。

読み込みは以下のように行います。

```vim
:r !cat <(echo -ne Salted__) ~/vim_enc_test_file | openssl aes-256-cbc -d
```

```bash
cat <(echo -ne Salted__) ~/vim_enc_test_file | openssl aes-256-cbc -d | vim -
```

ちなみに圧縮もしてみましょう。書き込みは以下の通りです。

```vim
:w !bzip2 | openssl aes-256-cbc | dd ibs=8 skip=1 of=~/vim_enc_test_file
```

読み込みは以下の通りです。

```vim
:r !cat <(echo -ne Salted__) ~/vim_enc_test_file | openssl aes-256-cbc -d | bzcat
```

```bash
cat <(echo -ne Salted__) ~/vim_enc_test_file | openssl aes-256-cbc -d | bzcat | vim -
```

さて、最後にあとひと押しです。
「aes-256-cbc」はパスワードが間違っている場合にエラーを出します。CentOS6.8 の場合は以下のエラーとなります。

```text
digital envelope routines:EVP_DecryptFinal_ex:wrong final block length
```

これは、総当りで復号化を試みるクラッカーにとっては助けにもなってしまいます。なぜなら、パスワードが間違っていることがわかるためです。
Mac 等では使えませんが、「aes-256-cbc」の代わりに「aes-256-ofb」を使うことで解決されます。
「aes-256-ofb」なら、パスワードが合っているのか間違っているのすらわかりません。
書き込みは以下の通りです。

```vim
:w !bzip2 | openssl aes-256-ofb | dd ibs=8 skip=1 of=~/vim_enc_test_file
```

読み込みは以下の通りです。

```vim
:r !cat <(echo -ne Salted__) ~/vim_enc_test_file | openssl aes-256-ofb -d | bzcat
```

```bash
cat <(echo -ne Salted__) ~/vim_enc_test_file | openssl aes-256-ofb -d | bzcat | vim -
```

パスワードが合っているのか間違っているのすらわからないというのは、つまりあなたのパスワードを突破しようとしても、パスワード 1 つ 1 つを確認しなければならないということです。
人間には不可能ですし、機械的に判定しようにも非常に手をこまねくはずです。
環境が許せばぜひやってみて下さい。

Vim と openssl で暗号化・復号をしようというお話でした。
みなさんもぜひやってみて下さい。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[JAVAで組み合わせ]]></title>
            <link>https://nishidemasami.github.io/posts/java-combination</link>
            <guid>https://nishidemasami.github.io/posts/java-combination</guid>
            <pubDate>Sat, 26 Nov 2016 00:04:03 GMT</pubDate>
            <description><![CDATA[JAVAで組み合わせを作成したいと思うこと、ありますよね。僕はあるので自分用にメモです。Ruby では組み合わせを作成することができるArray#combinationが用意されています。これを使えば、例えば下記のように…]]></description>
            <content:encoded><![CDATA[
JAVAで組み合わせを作成したいと思うこと、ありますよね。  
僕はあるので自分用にメモです。

Ruby では組み合わせを作成することができる[Array#combination](https://docs.ruby-lang.org/ja/latest/method/Array/i/combination.html)が用意されています。  
これを使えば、例えば下記のように

```ruby
require 'json'

jsonstr = <<JSON
[
  {
    "price": 432,
    "name": "hoge"
  },
  {
    "price": 531,
    "name": "fuga"
  },
  {
    "price": 568,
    "name": "piyo"
  }
]
JSON

p JSON.load(jsonstr)
    .combination(2)
    .to_a
    .select(&->x{x.reduce(&->x,y{x["price"] + y["price"]}) == 1000})
```

こうすれば、JSON の商品リストから price の合計が 1000 になるもの(hoge と piyo)を抜き出してくれます。

```ruby
[[{"price"=>432, "name"=>"hoge"}, {"price"=>568, "name"=>"piyo"}]]
```

非常にイージー。

ところが、combination は Java には無いんですよね。  
これを Java で書きたい時、どうすればいいのか悩みました。  
今回は再帰的なやりかたでやってみました。

```java
 * 組み合わせを返す
 *
 * @param parameter 組み合わせを作成するリスト
 * @param combinationCount 組み合わせの個数
 * @return 組み合わせのリスト
 */
private static final <E> List<List<E>> combination(
  final List<E> parameter,
  final long combinationCount) {

  final int parameterSize = parameter.size();

  if (parameterSize < combinationCount) {
    throw new IllegalArgumentException("リストの要素数が組み合わせ個数より少ないです。");
  } else if (combinationCount <= 0) {
    throw new IllegalArgumentException("組み合わせ個数が不正です。");
  } else if (combinationCount == 1) {
    List<List<E>> result = new LinkedList<List<E>>();
    parameter.forEach(x -> {
      List<E> resultWork = new LinkedList<E>();
      resultWork.add(x);
      result.add(resultWork);
    });
    return result;
  } else {
    List<List<E>> result = new LinkedList<List<E>>();
    for (int i = 0; i < parameterSize - combinationCount + 1; i++) {
      List<List<E>> resultWork = combination(
        parameter.subList(1 + i, parameterSize),
        combinationCount - 1);
      for (List<E> resultWorkForEach : resultWork) {
        resultWorkForEach.add(0, parameter.get(i));
      }
      result.addAll(resultWork);
    }
    return result;
  }
}
```

LinkedList を使っているのは先頭追加があるためです。  
ちょっと見た目がヘビーですが、使えます。  
こんな感じです。

```java
class Item {
  public Item(int price, String name){
    this.price = price;
    this.name = name;
  }
  int price;
  String name;

  @Override
  public String toString() {
    return name + ":" + price + "円";
  }
}

class Main {
  public static void main(String[] args) {
    List<Item> itemList = Arrays.asList(new Item[]{
      new Item(432, "hoge"),
      new Item(531, "fuga"),
      new Item(568, "piyo"),
      new Item(999, "meta")
    });

    combination(itemList,3)
      .stream()
      .forEach(x->{System.out.println(Arrays.toString(x.toArray()));});
  }
}
```

こうなります。

```json
[hoge:432円, fuga:531円, piyo:568円]
[hoge:432円, fuga:531円, meta:999円]
[hoge:432円, piyo:568円, meta:999円]
[fuga:531円, piyo:568円, meta:999円]
```

Ruby の例題と同じようにこうすると、

```java
combination(itemList,2)
  .stream()
  .filter(x-> x.stream().map(y -> y.price).reduce((y, z)-> y + z).get() == 1000)
  .forEach(x->{System.out.println(Arrays.toString(x.toArray()));});
```

こうなります。

```json
[hoge:432円, piyo:568円]
```

java8 の stream なのに遅延評価が役に立たないのは、Ruby も combination を[Enumerator::Lazy](https://docs.ruby-lang.org/ja/latest/class/Enumerator=3a=3aLazy.html)で使えないのと一緒ですね。  
java8 は遅延評価がデフォルトとなっているので、気軽に limit(1)などで一瞬で返ってくるつもりでいたら combination 部分が延々返ってこない…なんてことが発生しないようになのかもしれません。

Ruby で使えた combination が無くて困った話でした。
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[はじめまして]]></title>
            <link>https://nishidemasami.github.io/posts/hello-world</link>
            <guid>https://nishidemasami.github.io/posts/hello-world</guid>
            <pubDate>Thu, 30 Jun 2016 19:58:43 GMT</pubDate>
            <description><![CDATA[はじめての投稿です。]]></description>
            <content:encoded><![CDATA[
はじめての投稿です。
これから、なにか有益なことや無益なことを書いてゆこうと思います。
よろしくお願いします。
]]></content:encoded>
        </item>
    </channel>
</rss>